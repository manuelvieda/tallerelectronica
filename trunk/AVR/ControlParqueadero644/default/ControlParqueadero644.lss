
ControlParqueadero644.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000236  00000000  00000000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .debug_aranges 00000040  00000000  00000000  0000028a  2**0
                  CONTENTS, READONLY, DEBUGGING
  2 .debug_pubnames 00000076  00000000  00000000  000002ca  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_info   0000050a  00000000  00000000  00000340  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_abbrev 00000241  00000000  00000000  0000084a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_line   00000455  00000000  00000000  00000a8b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_frame  00000090  00000000  00000000  00000ee0  2**2
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_str    000001ba  00000000  00000000  00000f70  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00000141  00000000  00000000  0000112a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 38 00 	jmp	0x70	; 0x70 <__ctors_end>
   4:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
   8:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
   c:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  10:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  14:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  18:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  1c:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  20:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  24:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  28:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  2c:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  30:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  34:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  38:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  3c:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  40:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  44:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  48:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  4c:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  50:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  54:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  58:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  5c:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  60:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  64:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  68:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>
  6c:	0c 94 42 00 	jmp	0x84	; 0x84 <__bad_interrupt>

00000070 <__ctors_end>:
  70:	11 24       	eor	r1, r1
  72:	1f be       	out	0x3f, r1	; 63
  74:	cf ef       	ldi	r28, 0xFF	; 255
  76:	d0 e1       	ldi	r29, 0x10	; 16
  78:	de bf       	out	0x3e, r29	; 62
  7a:	cd bf       	out	0x3d, r28	; 61
  7c:	0e 94 44 00 	call	0x88	; 0x88 <main>
  80:	0c 94 19 01 	jmp	0x232	; 0x232 <_exit>

00000084 <__bad_interrupt>:
  84:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000088 <main>:

//  ------------------------------------------------------------------------
//	PROGRAMA PRINCIPAL DEL SISITEMA
//  ------------------------------------------------------------------------

int main(void) {
  88:	80 e9       	ldi	r24, 0x90	; 144
  8a:	91 e0       	ldi	r25, 0x01	; 1
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  8c:	28 ec       	ldi	r18, 0xC8	; 200
  8e:	30 e0       	ldi	r19, 0x00	; 0
  90:	f9 01       	movw	r30, r18
  92:	31 97       	sbiw	r30, 0x01	; 1
  94:	f1 f7       	brne	.-4      	; 0x92 <main+0xa>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
  96:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
  98:	d9 f7       	brne	.-10     	; 0x90 <main+0x8>


	_delay_ms(40);
	LCD_init();
  9a:	0e 94 ce 00 	call	0x19c	; 0x19c <LCD_init>

	//LCD_enviarDTA('E');LCD_esperarListo();

	LCD_linea1Pos0();
  9e:	80 e8       	ldi	r24, 0x80	; 128
  a0:	60 e0       	ldi	r22, 0x00	; 0
  a2:	0e 94 94 00 	call	0x128	; 0x128 <LCD_enviarByte>
	LCD_esperarListo();
  a6:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_esperarListo>
	LCD_enviarDTA('H');LCD_esperarListo();
  aa:	88 e4       	ldi	r24, 0x48	; 72
  ac:	61 e0       	ldi	r22, 0x01	; 1
  ae:	0e 94 94 00 	call	0x128	; 0x128 <LCD_enviarByte>
  b2:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_esperarListo>

	LCD_linea2Pos0(); LCD_esperarListo();
  b6:	84 e9       	ldi	r24, 0x94	; 148
  b8:	60 e0       	ldi	r22, 0x00	; 0
  ba:	0e 94 94 00 	call	0x128	; 0x128 <LCD_enviarByte>
  be:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_esperarListo>
	LCD_enviarDTA('L');LCD_esperarListo();
  c2:	8c e4       	ldi	r24, 0x4C	; 76
  c4:	61 e0       	ldi	r22, 0x01	; 1
  c6:	0e 94 94 00 	call	0x128	; 0x128 <LCD_enviarByte>
  ca:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_esperarListo>

	LCD_linea3Pos0(); LCD_esperarListo();
  ce:	80 ec       	ldi	r24, 0xC0	; 192
  d0:	60 e0       	ldi	r22, 0x00	; 0
  d2:	0e 94 94 00 	call	0x128	; 0x128 <LCD_enviarByte>
  d6:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_esperarListo>
	LCD_enviarDTA('P');LCD_esperarListo();
  da:	80 e5       	ldi	r24, 0x50	; 80
  dc:	61 e0       	ldi	r22, 0x01	; 1
  de:	0e 94 94 00 	call	0x128	; 0x128 <LCD_enviarByte>
  e2:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_esperarListo>

	LCD_linea4Pos0(); LCD_esperarListo();
  e6:	84 ed       	ldi	r24, 0xD4	; 212
  e8:	60 e0       	ldi	r22, 0x00	; 0
  ea:	0e 94 94 00 	call	0x128	; 0x128 <LCD_enviarByte>
  ee:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_esperarListo>
	LCD_enviarDTA('M');LCD_esperarListo();
  f2:	8d e4       	ldi	r24, 0x4D	; 77
  f4:	61 e0       	ldi	r22, 0x01	; 1
  f6:	0e 94 94 00 	call	0x128	; 0x128 <LCD_enviarByte>
  fa:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_esperarListo>
  fe:	ff cf       	rjmp	.-2      	; 0xfe <main+0x76>

00000100 <LCD_enviarNibble>:
 *			uint8_t rs -> Selector de registro LCD (1:Instruccion, 0:Dato)
 * @PRE: n y rs se encuentran bien definidos
 * @POS: Se envian los datos al LCD
 * @Return: Void
 */
static void LCD_enviarNibble(uint8_t n, uint8_t rs){
 100:	98 2f       	mov	r25, r24

	LCD_CMD_PORT_OUT &= ~_BV(LCD_RW);
 102:	41 98       	cbi	0x08, 1	; 8

	if (rs)
 104:	66 23       	and	r22, r22
 106:	11 f0       	breq	.+4      	; 0x10c <LCD_enviarNibble+0xc>
		LCD_CMD_PORT_OUT |= _BV(LCD_RS);
 108:	47 9a       	sbi	0x08, 7	; 8
 10a:	01 c0       	rjmp	.+2      	; 0x10e <LCD_enviarNibble+0xe>
	else
		LCD_CMD_PORT_OUT &= ~_BV(LCD_RS);
 10c:	47 98       	cbi	0x08, 7	; 8
	
	LCD_DTA_PORT_OUT &= ~LCD_DTA_BITS;
 10e:	85 b1       	in	r24, 0x05	; 5
 110:	80 7f       	andi	r24, 0xF0	; 240
 112:	85 b9       	out	0x05, r24	; 5
	LCD_DTA_PORT_OUT |= (n<<LCD_D4) & LCD_DTA_BITS;
 114:	85 b1       	in	r24, 0x05	; 5
 116:	9f 70       	andi	r25, 0x0F	; 15
 118:	89 2b       	or	r24, r25
 11a:	85 b9       	out	0x05, r24	; 5

static inline uint8_t LCD_pulsoEnable(bool lectura){
	
	uint8_t dato;
	
	LCD_CMD_PORT_OUT |= _BV(LCD_E);
 11c:	40 9a       	sbi	0x08, 0	; 8
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 11e:	81 e0       	ldi	r24, 0x01	; 1
 120:	8a 95       	dec	r24
 122:	f1 f7       	brne	.-4      	; 0x120 <LCD_enviarNibble+0x20>
	if(lectura)
		dato = LCD_DTA_PORT_IN & LCD_DTA_BITS;
	else
		dato = 0x00;

	LCD_CMD_PORT_OUT &= ~_BV(LCD_E);
 124:	40 98       	cbi	0x08, 0	; 8
	
	LCD_DTA_PORT_OUT &= ~LCD_DTA_BITS;
	LCD_DTA_PORT_OUT |= (n<<LCD_D4) & LCD_DTA_BITS;
	//LCD_DTA_PORT_OUT |= ((n<<LCD_D4)& LCD_DTA_BITS);
	(void)LCD_pulsoEnable(false);
}
 126:	08 95       	ret

00000128 <LCD_enviarByte>:
 * @PRE: Los parametros se encuentran bien definidos
 * @POS: Se envian dos nibbles para completar el dato/instruccion en el controlador del LCD
 * @RETURN: Void
 */

void LCD_enviarByte(uint8_t by, uint8_t rs){
 128:	0f 93       	push	r16
 12a:	1f 93       	push	r17
 12c:	18 2f       	mov	r17, r24
 12e:	06 2f       	mov	r16, r22

	LCD_enviarNibble(by>>4, rs);		// Enviamos la parte alta b[7..4]
 130:	82 95       	swap	r24
 132:	8f 70       	andi	r24, 0x0F	; 15
 134:	0e 94 80 00 	call	0x100	; 0x100 <LCD_enviarNibble>
	LCD_enviarNibble(by & 0x0F, rs);	// Enviamos la parte baja b[3..0]
 138:	81 2f       	mov	r24, r17
 13a:	8f 70       	andi	r24, 0x0F	; 15
 13c:	60 2f       	mov	r22, r16
 13e:	0e 94 80 00 	call	0x100	; 0x100 <LCD_enviarNibble>
}
 142:	1f 91       	pop	r17
 144:	0f 91       	pop	r16
 146:	08 95       	ret

00000148 <LCD_recibirNibble>:
 */
static uint8_t LCD_recibirNibble(uint8_t rs){
	
	uint8_t dato;

	LCD_CMD_PORT_OUT |= _BV(LCD_RW);
 148:	41 9a       	sbi	0x08, 1	; 8

	LCD_DTA_PORT_DDR &= ~LCD_DTA_BITS;
 14a:	94 b1       	in	r25, 0x04	; 4
 14c:	90 7f       	andi	r25, 0xF0	; 240
 14e:	94 b9       	out	0x04, r25	; 4

	if (rs)
 150:	88 23       	and	r24, r24
 152:	11 f0       	breq	.+4      	; 0x158 <LCD_recibirNibble+0x10>
		LCD_CMD_PORT_OUT |= _BV(LCD_RS);
 154:	47 9a       	sbi	0x08, 7	; 8
 156:	01 c0       	rjmp	.+2      	; 0x15a <LCD_recibirNibble+0x12>
	else
		LCD_CMD_PORT_OUT &= ~_BV(LCD_RS);
 158:	47 98       	cbi	0x08, 7	; 8

static inline uint8_t LCD_pulsoEnable(bool lectura){
	
	uint8_t dato;
	
	LCD_CMD_PORT_OUT |= _BV(LCD_E);
 15a:	40 9a       	sbi	0x08, 0	; 8
 15c:	81 e0       	ldi	r24, 0x01	; 1
 15e:	8a 95       	dec	r24
 160:	f1 f7       	brne	.-4      	; 0x15e <LCD_recibirNibble+0x16>
		#endif /* F_CPU > 2000000UL */
		#endif /* F_CPU > 1000000UL */
	#endif /* F_CPU > 4000000UL */

	if(lectura)
		dato = LCD_DTA_PORT_IN & LCD_DTA_BITS;
 162:	83 b1       	in	r24, 0x03	; 3
	else
		dato = 0x00;

	LCD_CMD_PORT_OUT &= ~_BV(LCD_E);
 164:	40 98       	cbi	0x08, 0	; 8
	else
		LCD_CMD_PORT_OUT &= ~_BV(LCD_RS);
	
	dato = LCD_pulsoEnable(true);

	LCD_DTA_PORT_DDR |= LCD_DTA_BITS;
 166:	94 b1       	in	r25, 0x04	; 4
 168:	9f 60       	ori	r25, 0x0F	; 15
 16a:	94 b9       	out	0x04, r25	; 4
	LCD_CMD_PORT_OUT &= ~_BV(LCD_RW);
 16c:	41 98       	cbi	0x08, 1	; 8

	return (dato & LCD_DTA_BITS)>>LCD_D4;


}
 16e:	8f 70       	andi	r24, 0x0F	; 15
 170:	08 95       	ret

00000172 <LCD_recibirByte>:
 * @PRE: Los parametros se encuentran bien definidos
 * @POS: Se reciben dos nibbles para completar el dato/instruccion proveniente del controlador del LCD
 * @RETURN: Void
 */

uint8_t LCD_recibirByte(uint8_t rs){
 172:	0f 93       	push	r16
 174:	1f 93       	push	r17
 176:	18 2f       	mov	r17, r24
	
	uint8_t dato;
	dato = LCD_recibirNibble(rs) << 4;
 178:	0e 94 a4 00 	call	0x148	; 0x148 <LCD_recibirNibble>
 17c:	08 2f       	mov	r16, r24
 17e:	02 95       	swap	r16
 180:	00 7f       	andi	r16, 0xF0	; 240
	dato |= LCD_recibirNibble(rs);
 182:	81 2f       	mov	r24, r17
 184:	0e 94 a4 00 	call	0x148	; 0x148 <LCD_recibirNibble>
	return dato;

}
 188:	80 2b       	or	r24, r16
 18a:	1f 91       	pop	r17
 18c:	0f 91       	pop	r16
 18e:	08 95       	ret

00000190 <LCD_esperarListo>:
/**
 * Este metodo genera una espera activa mientras se encuentra activada la bandera de ocupado
 * del controlador del LCD.
 */
void LCD_esperarListo(void){
	while( LCD_recibirByte(0) & LCD_BUSYFLAG);
 190:	80 e0       	ldi	r24, 0x00	; 0
 192:	0e 94 b9 00 	call	0x172	; 0x172 <LCD_recibirByte>
 196:	87 fd       	sbrc	r24, 7
 198:	fb cf       	rjmp	.-10     	; 0x190 <LCD_esperarListo>
}
 19a:	08 95       	ret

0000019c <LCD_init>:
 * @PRE: El voltaje ya se debe haber estabilizado tanto en el micro como en el LCD
 * @POS: Se inicializa el protocolo de comunicacion con el controlador del LCD con 
 *		 las opciones escogidas en el archivo 'defines.h'
 * @RETURN: Void
 */
void LCD_init(void){
 19c:	0f 93       	push	r16
 19e:	1f 93       	push	r17
	
	LCD_CMD_PORT_DDR |= _BV(LCD_RS)|_BV(LCD_RW)|_BV(LCD_E);
 1a0:	87 b1       	in	r24, 0x07	; 7
 1a2:	83 68       	ori	r24, 0x83	; 131
 1a4:	87 b9       	out	0x07, r24	; 7
	LCD_DTA_PORT_DDR |= LCD_DTA_BITS;
 1a6:	84 b1       	in	r24, 0x04	; 4
 1a8:	8f 60       	ori	r24, 0x0F	; 15
 1aa:	84 b9       	out	0x04, r24	; 4
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 1ac:	80 e4       	ldi	r24, 0x40	; 64
 1ae:	9c e9       	ldi	r25, 0x9C	; 156
 1b0:	01 97       	sbiw	r24, 0x01	; 1
 1b2:	f1 f7       	brne	.-4      	; 0x1b0 <LCD_init+0x14>
	_delay_ms(20);

	// Se realiza una inicializacion por instrucciones para evitar problemas si
	// la fuente no es capaz de generar una inicializacion por reset automatico

	LCD_enviarNibble(0x03, 0);
 1b4:	83 e0       	ldi	r24, 0x03	; 3
 1b6:	60 e0       	ldi	r22, 0x00	; 0
 1b8:	0e 94 80 00 	call	0x100	; 0x100 <LCD_enviarNibble>
 1bc:	80 e1       	ldi	r24, 0x10	; 16
 1be:	97 e2       	ldi	r25, 0x27	; 39
 1c0:	01 97       	sbiw	r24, 0x01	; 1
 1c2:	f1 f7       	brne	.-4      	; 0x1c0 <LCD_init+0x24>
	_delay_ms(5);
	LCD_enviarNibble(0x03, 0);
 1c4:	83 e0       	ldi	r24, 0x03	; 3
 1c6:	60 e0       	ldi	r22, 0x00	; 0
 1c8:	0e 94 80 00 	call	0x100	; 0x100 <LCD_enviarNibble>
 1cc:	08 ee       	ldi	r16, 0xE8	; 232
 1ce:	13 e0       	ldi	r17, 0x03	; 3
 1d0:	c8 01       	movw	r24, r16
 1d2:	01 97       	sbiw	r24, 0x01	; 1
 1d4:	f1 f7       	brne	.-4      	; 0x1d2 <LCD_init+0x36>
	_delay_ms(0.5);
	LCD_enviarNibble(0x03, 0);
 1d6:	83 e0       	ldi	r24, 0x03	; 3
 1d8:	60 e0       	ldi	r22, 0x00	; 0
 1da:	0e 94 80 00 	call	0x100	; 0x100 <LCD_enviarNibble>
 1de:	c8 01       	movw	r24, r16
 1e0:	01 97       	sbiw	r24, 0x01	; 1
 1e2:	f1 f7       	brne	.-4      	; 0x1e0 <LCD_init+0x44>
	_delay_ms(0.5);


	LCD_enviarNibble( LCD_FNSET>>4, 0);
 1e4:	82 e0       	ldi	r24, 0x02	; 2
 1e6:	60 e0       	ldi	r22, 0x00	; 0
 1e8:	0e 94 80 00 	call	0x100	; 0x100 <LCD_enviarNibble>
	LCD_esperarListo();
 1ec:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_esperarListo>
	LCD_enviarByte( LCD_FNSET, 0);
 1f0:	88 e2       	ldi	r24, 0x28	; 40
 1f2:	60 e0       	ldi	r22, 0x00	; 0
 1f4:	0e 94 94 00 	call	0x128	; 0x128 <LCD_enviarByte>
	LCD_esperarListo();
 1f8:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_esperarListo>
	LCD_enviarByte( LCD_DSPCTR, 0);
 1fc:	8c e0       	ldi	r24, 0x0C	; 12
 1fe:	60 e0       	ldi	r22, 0x00	; 0
 200:	0e 94 94 00 	call	0x128	; 0x128 <LCD_enviarByte>
	LCD_esperarListo();
 204:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_esperarListo>
	LCD_enviarByte( LCD_ENTMOD, 0);
 208:	86 e0       	ldi	r24, 0x06	; 6
 20a:	60 e0       	ldi	r22, 0x00	; 0
 20c:	0e 94 94 00 	call	0x128	; 0x128 <LCD_enviarByte>
	LCD_esperarListo();
 210:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_esperarListo>
	LCD_enviarByte( 0x01, 0);
 214:	81 e0       	ldi	r24, 0x01	; 1
 216:	60 e0       	ldi	r22, 0x00	; 0
 218:	0e 94 94 00 	call	0x128	; 0x128 <LCD_enviarByte>
	LCD_esperarListo();
 21c:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_esperarListo>
	LCD_enviarByte( 0x02, 0);
 220:	82 e0       	ldi	r24, 0x02	; 2
 222:	60 e0       	ldi	r22, 0x00	; 0
 224:	0e 94 94 00 	call	0x128	; 0x128 <LCD_enviarByte>
	LCD_esperarListo();
 228:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_esperarListo>

}
 22c:	1f 91       	pop	r17
 22e:	0f 91       	pop	r16
 230:	08 95       	ret

00000232 <_exit>:
 232:	f8 94       	cli

00000234 <__stop_program>:
 234:	ff cf       	rjmp	.-2      	; 0x234 <__stop_program>
